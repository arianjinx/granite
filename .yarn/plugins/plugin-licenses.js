/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
"use strict";var plugin=(()=>{var It=Object.create;var j=Object.defineProperty;var zt=Object.getOwnPropertyDescriptor;var Mt=Object.getOwnPropertyNames;var Nt=Object.getPrototypeOf,jt=Object.prototype.hasOwnProperty;var A=(s=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(s,{get:(t,e)=>(typeof require<"u"?require:t)[e]}):s)(function(s){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+s+'" is not supported')});var M=(s,t)=>()=>(t||s((t={exports:{}}).exports,t),t.exports),H=(s,t)=>{for(var e in t)j(s,e,{get:t[e],enumerable:!0})},ut=(s,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Mt(t))!jt.call(s,n)&&n!==e&&j(s,n,{get:()=>t[n],enumerable:!(i=zt(t,n))||i.enumerable});return s};var Ht=(s,t,e)=>(e=s!=null?It(Nt(s)):{},ut(t||!s||!s.__esModule?j(e,"default",{value:s,enumerable:!0}):e,s)),Gt=s=>ut(j({},"__esModule",{value:!0}),s);var wt=M(B=>{"use strict";Object.defineProperty(B,"__esModule",{value:!0});B.LRUCache=void 0;var D=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,pt=new Set,Z=typeof process=="object"&&process?process:{},mt=(s,t,e,i)=>{typeof Z.emitWarning=="function"?Z.emitWarning(s,t,e,i):console.error(`[${e}] ${t}: ${s}`)},G=globalThis.AbortController,dt=globalThis.AbortSignal;if(typeof G>"u"){dt=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(i,n){this._onabort.push(n)}},G=class{constructor(){t()}signal=new dt;abort(i){if(!this.signal.aborted){this.signal.reason=i,this.signal.aborted=!0;for(let n of this.signal._onabort)n(i);this.signal.onabort?.(i)}}};let s=Z.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",t=()=>{s&&(s=!1,mt("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",t))}}var Bt=s=>!pt.has(s),Se=Symbol("type"),E=s=>s&&s===Math.floor(s)&&s>0&&isFinite(s),gt=s=>E(s)?s<=Math.pow(2,8)?Uint8Array:s<=Math.pow(2,16)?Uint16Array:s<=Math.pow(2,32)?Uint32Array:s<=Number.MAX_SAFE_INTEGER?R:null:null,R=class extends Array{constructor(t){super(t),this.fill(0)}},tt=class s{heap;length;static#n=!1;static create(t){let e=gt(t);if(!e)return[];s.#n=!0;let i=new s(t,e);return s.#n=!1,i}constructor(t,e){if(!s.#n)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}},et=class s{#n;#l;#e;#g;#x;#k;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#r;#w;#o;#i;#t;#f;#d;#c;#a;#b;#h;#y;#$;#p;#S;#T;#u;static unsafeExposeInternals(t){return{starts:t.#$,ttls:t.#p,sizes:t.#y,keyMap:t.#o,keyList:t.#i,valList:t.#t,next:t.#f,prev:t.#d,get head(){return t.#c},get tail(){return t.#a},free:t.#b,isBackgroundFetch:e=>t.#s(e),backgroundFetch:(e,i,n,o)=>t.#W(e,i,n,o),moveToTail:e=>t.#E(e),indexes:e=>t.#P(e),rindexes:e=>t.#A(e),isStale:e=>t.#m(e)}}get max(){return this.#n}get maxSize(){return this.#l}get calculatedSize(){return this.#w}get size(){return this.#r}get fetchMethod(){return this.#x}get memoMethod(){return this.#k}get dispose(){return this.#e}get disposeAfter(){return this.#g}constructor(t){let{max:e=0,ttl:i,ttlResolution:n=1,ttlAutopurge:o,updateAgeOnGet:r,updateAgeOnHas:a,allowStale:h,dispose:f,disposeAfter:w,noDisposeOnSet:u,noUpdateTTL:m,maxSize:p=0,maxEntrySize:P=0,sizeCalculation:l,fetchMethod:y,memoMethod:c,noDeleteOnFetchRejection:S,noDeleteOnStaleGet:O,allowStaleOnFetchRejection:$,allowStaleOnFetchAbort:v,ignoreFetchAbort:L}=t;if(e!==0&&!E(e))throw new TypeError("max option must be a nonnegative integer");let T=e?gt(e):Array;if(!T)throw new Error("invalid max value: "+e);if(this.#n=e,this.#l=p,this.maxEntrySize=P||this.#l,this.sizeCalculation=l,this.sizeCalculation){if(!this.#l&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(c!==void 0&&typeof c!="function")throw new TypeError("memoMethod must be a function if defined");if(this.#k=c,y!==void 0&&typeof y!="function")throw new TypeError("fetchMethod must be a function if specified");if(this.#x=y,this.#T=!!y,this.#o=new Map,this.#i=new Array(e).fill(void 0),this.#t=new Array(e).fill(void 0),this.#f=new T(e),this.#d=new T(e),this.#c=0,this.#a=0,this.#b=tt.create(e),this.#r=0,this.#w=0,typeof f=="function"&&(this.#e=f),typeof w=="function"?(this.#g=w,this.#h=[]):(this.#g=void 0,this.#h=void 0),this.#S=!!this.#e,this.#u=!!this.#g,this.noDisposeOnSet=!!u,this.noUpdateTTL=!!m,this.noDeleteOnFetchRejection=!!S,this.allowStaleOnFetchRejection=!!$,this.allowStaleOnFetchAbort=!!v,this.ignoreFetchAbort=!!L,this.maxEntrySize!==0){if(this.#l!==0&&!E(this.#l))throw new TypeError("maxSize must be a positive integer if specified");if(!E(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#N()}if(this.allowStale=!!h,this.noDeleteOnStaleGet=!!O,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!a,this.ttlResolution=E(n)||n===0?n:1,this.ttlAutopurge=!!o,this.ttl=i||0,this.ttl){if(!E(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#U()}if(this.#n===0&&this.ttl===0&&this.#l===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#n&&!this.#l){let U="LRU_CACHE_UNBOUNDED";Bt(U)&&(pt.add(U),mt("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",U,s))}}getRemainingTTL(t){return this.#o.has(t)?1/0:0}#U(){let t=new R(this.#n),e=new R(this.#n);this.#p=t,this.#$=e,this.#D=(o,r,a=D.now())=>{if(e[o]=r!==0?a:0,t[o]=r,r!==0&&this.ttlAutopurge){let h=setTimeout(()=>{this.#m(o)&&this.#v(this.#i[o],"expire")},r+1);h.unref&&h.unref()}},this.#F=o=>{e[o]=t[o]!==0?D.now():0},this.#O=(o,r)=>{if(t[r]){let a=t[r],h=e[r];if(!a||!h)return;o.ttl=a,o.start=h,o.now=i||n();let f=o.now-h;o.remainingTTL=a-f}};let i=0,n=()=>{let o=D.now();if(this.ttlResolution>0){i=o;let r=setTimeout(()=>i=0,this.ttlResolution);r.unref&&r.unref()}return o};this.getRemainingTTL=o=>{let r=this.#o.get(o);if(r===void 0)return 0;let a=t[r],h=e[r];if(!a||!h)return 1/0;let f=(i||n())-h;return a-f},this.#m=o=>{let r=e[o],a=t[o];return!!a&&!!r&&(i||n())-r>a}}#F=()=>{};#O=()=>{};#D=()=>{};#m=()=>!1;#N(){let t=new R(this.#n);this.#w=0,this.#y=t,this.#_=e=>{this.#w-=t[e],t[e]=0},this.#R=(e,i,n,o)=>{if(this.#s(i))return 0;if(!E(n))if(o){if(typeof o!="function")throw new TypeError("sizeCalculation must be a function");if(n=o(i,e),!E(n))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return n},this.#L=(e,i,n)=>{if(t[e]=i,this.#l){let o=this.#l-t[e];for(;this.#w>o;)this.#C(!0)}this.#w+=t[e],n&&(n.entrySize=i,n.totalCalculatedSize=this.#w)}}#_=t=>{};#L=(t,e,i)=>{};#R=(t,e,i,n)=>{if(i||n)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#P({allowStale:t=this.allowStale}={}){if(this.#r)for(let e=this.#a;!(!this.#I(e)||((t||!this.#m(e))&&(yield e),e===this.#c));)e=this.#d[e]}*#A({allowStale:t=this.allowStale}={}){if(this.#r)for(let e=this.#c;!(!this.#I(e)||((t||!this.#m(e))&&(yield e),e===this.#a));)e=this.#f[e]}#I(t){return t!==void 0&&this.#o.get(this.#i[t])===t}*entries(){for(let t of this.#P())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#s(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*rentries(){for(let t of this.#A())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#s(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*keys(){for(let t of this.#P()){let e=this.#i[t];e!==void 0&&!this.#s(this.#t[t])&&(yield e)}}*rkeys(){for(let t of this.#A()){let e=this.#i[t];e!==void 0&&!this.#s(this.#t[t])&&(yield e)}}*values(){for(let t of this.#P())this.#t[t]!==void 0&&!this.#s(this.#t[t])&&(yield this.#t[t])}*rvalues(){for(let t of this.#A())this.#t[t]!==void 0&&!this.#s(this.#t[t])&&(yield this.#t[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#P()){let n=this.#t[i],o=this.#s(n)?n.__staleWhileFetching:n;if(o!==void 0&&t(o,this.#i[i],this))return this.get(this.#i[i],e)}}forEach(t,e=this){for(let i of this.#P()){let n=this.#t[i],o=this.#s(n)?n.__staleWhileFetching:n;o!==void 0&&t.call(e,o,this.#i[i],this)}}rforEach(t,e=this){for(let i of this.#A()){let n=this.#t[i],o=this.#s(n)?n.__staleWhileFetching:n;o!==void 0&&t.call(e,o,this.#i[i],this)}}purgeStale(){let t=!1;for(let e of this.#A({allowStale:!0}))this.#m(e)&&(this.#v(this.#i[e],"expire"),t=!0);return t}info(t){let e=this.#o.get(t);if(e===void 0)return;let i=this.#t[e],n=this.#s(i)?i.__staleWhileFetching:i;if(n===void 0)return;let o={value:n};if(this.#p&&this.#$){let r=this.#p[e],a=this.#$[e];if(r&&a){let h=r-(D.now()-a);o.ttl=h,o.start=Date.now()}}return this.#y&&(o.size=this.#y[e]),o}dump(){let t=[];for(let e of this.#P({allowStale:!0})){let i=this.#i[e],n=this.#t[e],o=this.#s(n)?n.__staleWhileFetching:n;if(o===void 0||i===void 0)continue;let r={value:o};if(this.#p&&this.#$){r.ttl=this.#p[e];let a=D.now()-this.#$[e];r.start=Math.floor(Date.now()-a)}this.#y&&(r.size=this.#y[e]),t.unshift([i,r])}return t}load(t){this.clear();for(let[e,i]of t){if(i.start){let n=Date.now()-i.start;i.start=D.now()-n}this.set(e,i.value,i)}}set(t,e,i={}){if(e===void 0)return this.delete(t),this;let{ttl:n=this.ttl,start:o,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:h}=i,{noUpdateTTL:f=this.noUpdateTTL}=i,w=this.#R(t,e,i.size||0,a);if(this.maxEntrySize&&w>this.maxEntrySize)return h&&(h.set="miss",h.maxEntrySizeExceeded=!0),this.#v(t,"set"),this;let u=this.#r===0?void 0:this.#o.get(t);if(u===void 0)u=this.#r===0?this.#a:this.#b.length!==0?this.#b.pop():this.#r===this.#n?this.#C(!1):this.#r,this.#i[u]=t,this.#t[u]=e,this.#o.set(t,u),this.#f[this.#a]=u,this.#d[u]=this.#a,this.#a=u,this.#r++,this.#L(u,w,h),h&&(h.set="add"),f=!1;else{this.#E(u);let m=this.#t[u];if(e!==m){if(this.#T&&this.#s(m)){m.__abortController.abort(new Error("replaced"));let{__staleWhileFetching:p}=m;p!==void 0&&!r&&(this.#S&&this.#e?.(p,t,"set"),this.#u&&this.#h?.push([p,t,"set"]))}else r||(this.#S&&this.#e?.(m,t,"set"),this.#u&&this.#h?.push([m,t,"set"]));if(this.#_(u),this.#L(u,w,h),this.#t[u]=e,h){h.set="replace";let p=m&&this.#s(m)?m.__staleWhileFetching:m;p!==void 0&&(h.oldValue=p)}}else h&&(h.set="update")}if(n!==0&&!this.#p&&this.#U(),this.#p&&(f||this.#D(u,n,o),h&&this.#O(h,u)),!r&&this.#u&&this.#h){let m=this.#h,p;for(;p=m?.shift();)this.#g?.(...p)}return this}pop(){try{for(;this.#r;){let t=this.#t[this.#c];if(this.#C(!0),this.#s(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(t!==void 0)return t}}finally{if(this.#u&&this.#h){let t=this.#h,e;for(;e=t?.shift();)this.#g?.(...e)}}}#C(t){let e=this.#c,i=this.#i[e],n=this.#t[e];return this.#T&&this.#s(n)?n.__abortController.abort(new Error("evicted")):(this.#S||this.#u)&&(this.#S&&this.#e?.(n,i,"evict"),this.#u&&this.#h?.push([n,i,"evict"])),this.#_(e),t&&(this.#i[e]=void 0,this.#t[e]=void 0,this.#b.push(e)),this.#r===1?(this.#c=this.#a=0,this.#b.length=0):this.#c=this.#f[e],this.#o.delete(i),this.#r--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:n}=e,o=this.#o.get(t);if(o!==void 0){let r=this.#t[o];if(this.#s(r)&&r.__staleWhileFetching===void 0)return!1;if(this.#m(o))n&&(n.has="stale",this.#O(n,o));else return i&&this.#F(o),n&&(n.has="hit",this.#O(n,o)),!0}else n&&(n.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,n=this.#o.get(t);if(n===void 0||!i&&this.#m(n))return;let o=this.#t[n];return this.#s(o)?o.__staleWhileFetching:o}#W(t,e,i,n){let o=e===void 0?void 0:this.#t[e];if(this.#s(o))return o;let r=new G,{signal:a}=i;a?.addEventListener("abort",()=>r.abort(a.reason),{signal:r.signal});let h={signal:r.signal,options:i,context:n},f=(l,y=!1)=>{let{aborted:c}=r.signal,S=i.ignoreFetchAbort&&l!==void 0;if(i.status&&(c&&!y?(i.status.fetchAborted=!0,i.status.fetchError=r.signal.reason,S&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),c&&!S&&!y)return u(r.signal.reason);let O=p;return this.#t[e]===p&&(l===void 0?O.__staleWhileFetching?this.#t[e]=O.__staleWhileFetching:this.#v(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,l,h.options))),l},w=l=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=l),u(l)),u=l=>{let{aborted:y}=r.signal,c=y&&i.allowStaleOnFetchAbort,S=c||i.allowStaleOnFetchRejection,O=S||i.noDeleteOnFetchRejection,$=p;if(this.#t[e]===p&&(!O||$.__staleWhileFetching===void 0?this.#v(t,"fetch"):c||(this.#t[e]=$.__staleWhileFetching)),S)return i.status&&$.__staleWhileFetching!==void 0&&(i.status.returnedStale=!0),$.__staleWhileFetching;if($.__returned===$)throw l},m=(l,y)=>{let c=this.#x?.(t,o,h);c&&c instanceof Promise&&c.then(S=>l(S===void 0?void 0:S),y),r.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(l(void 0),i.allowStaleOnFetchAbort&&(l=S=>f(S,!0)))})};i.status&&(i.status.fetchDispatched=!0);let p=new Promise(m).then(f,w),P=Object.assign(p,{__abortController:r,__staleWhileFetching:o,__returned:void 0});return e===void 0?(this.set(t,P,{...h.options,status:void 0}),e=this.#o.get(t)):this.#t[e]=P,P}#s(t){if(!this.#T)return!1;let e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof G}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:h=0,sizeCalculation:f=this.sizeCalculation,noUpdateTTL:w=this.noUpdateTTL,noDeleteOnFetchRejection:u=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:m=this.allowStaleOnFetchRejection,ignoreFetchAbort:p=this.ignoreFetchAbort,allowStaleOnFetchAbort:P=this.allowStaleOnFetchAbort,context:l,forceRefresh:y=!1,status:c,signal:S}=e;if(!this.#T)return c&&(c.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:n,noDeleteOnStaleGet:o,status:c});let O={allowStale:i,updateAgeOnGet:n,noDeleteOnStaleGet:o,ttl:r,noDisposeOnSet:a,size:h,sizeCalculation:f,noUpdateTTL:w,noDeleteOnFetchRejection:u,allowStaleOnFetchRejection:m,allowStaleOnFetchAbort:P,ignoreFetchAbort:p,status:c,signal:S},$=this.#o.get(t);if($===void 0){c&&(c.fetch="miss");let v=this.#W(t,$,O,l);return v.__returned=v}else{let v=this.#t[$];if(this.#s(v)){let ft=i&&v.__staleWhileFetching!==void 0;return c&&(c.fetch="inflight",ft&&(c.returnedStale=!0)),ft?v.__staleWhileFetching:v.__returned=v}let L=this.#m($);if(!y&&!L)return c&&(c.fetch="hit"),this.#E($),n&&this.#F($),c&&this.#O(c,$),v;let T=this.#W(t,$,O,l),Q=T.__staleWhileFetching!==void 0&&i;return c&&(c.fetch=L?"stale":"refresh",Q&&L&&(c.returnedStale=!0)),Q?T.__staleWhileFetching:T.__returned=T}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(i===void 0)throw new Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#k;if(!i)throw new Error("no memoMethod provided to constructor");let{context:n,forceRefresh:o,...r}=e,a=this.get(t,r);if(!o&&a!==void 0)return a;let h=i(t,a,{options:r,context:n});return this.set(t,h,r),h}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,status:r}=e,a=this.#o.get(t);if(a!==void 0){let h=this.#t[a],f=this.#s(h);return r&&this.#O(r,a),this.#m(a)?(r&&(r.get="stale"),f?(r&&i&&h.__staleWhileFetching!==void 0&&(r.returnedStale=!0),i?h.__staleWhileFetching:void 0):(o||this.#v(t,"expire"),r&&i&&(r.returnedStale=!0),i?h:void 0)):(r&&(r.get="hit"),f?h.__staleWhileFetching:(this.#E(a),n&&this.#F(a),h))}else r&&(r.get="miss")}#z(t,e){this.#d[e]=t,this.#f[t]=e}#E(t){t!==this.#a&&(t===this.#c?this.#c=this.#f[t]:this.#z(this.#d[t],this.#f[t]),this.#z(this.#a,t),this.#a=t)}delete(t){return this.#v(t,"delete")}#v(t,e){let i=!1;if(this.#r!==0){let n=this.#o.get(t);if(n!==void 0)if(i=!0,this.#r===1)this.#M(e);else{this.#_(n);let o=this.#t[n];if(this.#s(o)?o.__abortController.abort(new Error("deleted")):(this.#S||this.#u)&&(this.#S&&this.#e?.(o,t,e),this.#u&&this.#h?.push([o,t,e])),this.#o.delete(t),this.#i[n]=void 0,this.#t[n]=void 0,n===this.#a)this.#a=this.#d[n];else if(n===this.#c)this.#c=this.#f[n];else{let r=this.#d[n];this.#f[r]=this.#f[n];let a=this.#f[n];this.#d[a]=this.#d[n]}this.#r--,this.#b.push(n)}}if(this.#u&&this.#h?.length){let n=this.#h,o;for(;o=n?.shift();)this.#g?.(...o)}return i}clear(){return this.#M("delete")}#M(t){for(let e of this.#A({allowStale:!0})){let i=this.#t[e];if(this.#s(i))i.__abortController.abort(new Error("deleted"));else{let n=this.#i[e];this.#S&&this.#e?.(i,n,t),this.#u&&this.#h?.push([i,n,t])}}if(this.#o.clear(),this.#t.fill(void 0),this.#i.fill(void 0),this.#p&&this.#$&&(this.#p.fill(0),this.#$.fill(0)),this.#y&&this.#y.fill(0),this.#c=0,this.#a=0,this.#b.length=0,this.#w=0,this.#r=0,this.#u&&this.#h){let e=this.#h,i;for(;i=e?.shift();)this.#g?.(...i)}}};B.LRUCache=et});var $t=M((Ae,yt)=>{"use strict";var d=(...s)=>s.every(t=>t)?s.join(""):"",b=s=>s?encodeURIComponent(s):"",bt=s=>s.toLowerCase().replace(/^\W+/g,"").replace(/(?<!\W)\W+$/,"").replace(/\//g,"").replace(/\W+/g,"-"),Vt={sshtemplate:({domain:s,user:t,project:e,committish:i})=>`git@${s}:${t}/${e}.git${d("#",i)}`,sshurltemplate:({domain:s,user:t,project:e,committish:i})=>`git+ssh://git@${s}/${t}/${e}.git${d("#",i)}`,edittemplate:({domain:s,user:t,project:e,committish:i,editpath:n,path:o})=>`https://${s}/${t}/${e}${d("/",n,"/",b(i||"HEAD"),"/",o)}`,browsetemplate:({domain:s,user:t,project:e,committish:i,treepath:n})=>`https://${s}/${t}/${e}${d("/",n,"/",b(i))}`,browsetreetemplate:({domain:s,user:t,project:e,committish:i,treepath:n,path:o,fragment:r,hashformat:a})=>`https://${s}/${t}/${e}/${n}/${b(i||"HEAD")}/${o}${d("#",a(r||""))}`,browseblobtemplate:({domain:s,user:t,project:e,committish:i,blobpath:n,path:o,fragment:r,hashformat:a})=>`https://${s}/${t}/${e}/${n}/${b(i||"HEAD")}/${o}${d("#",a(r||""))}`,docstemplate:({domain:s,user:t,project:e,treepath:i,committish:n})=>`https://${s}/${t}/${e}${d("/",i,"/",b(n))}#readme`,httpstemplate:({auth:s,domain:t,user:e,project:i,committish:n})=>`git+https://${d(s,"@")}${t}/${e}/${i}.git${d("#",n)}`,filetemplate:({domain:s,user:t,project:e,committish:i,path:n})=>`https://${s}/${t}/${e}/raw/${b(i||"HEAD")}/${n}`,shortcuttemplate:({type:s,user:t,project:e,committish:i})=>`${s}:${t}/${e}${d("#",i)}`,pathtemplate:({user:s,project:t,committish:e})=>`${s}/${t}${d("#",e)}`,bugstemplate:({domain:s,user:t,project:e})=>`https://${s}/${t}/${e}/issues`,hashformat:bt},x={};x.github={protocols:["git:","http:","git+ssh:","git+https:","ssh:","https:"],domain:"github.com",treepath:"tree",blobpath:"blob",editpath:"edit",filetemplate:({auth:s,user:t,project:e,committish:i,path:n})=>`https://${d(s,"@")}raw.githubusercontent.com/${t}/${e}/${b(i||"HEAD")}/${n}`,gittemplate:({auth:s,domain:t,user:e,project:i,committish:n})=>`git://${d(s,"@")}${t}/${e}/${i}.git${d("#",n)}`,tarballtemplate:({domain:s,user:t,project:e,committish:i})=>`https://codeload.${s}/${t}/${e}/tar.gz/${b(i||"HEAD")}`,extract:s=>{let[,t,e,i,n]=s.pathname.split("/",5);if(!(i&&i!=="tree")&&(i||(n=s.hash.slice(1)),e&&e.endsWith(".git")&&(e=e.slice(0,-4)),!(!t||!e)))return{user:t,project:e,committish:n}}};x.bitbucket={protocols:["git+ssh:","git+https:","ssh:","https:"],domain:"bitbucket.org",treepath:"src",blobpath:"src",editpath:"?mode=edit",edittemplate:({domain:s,user:t,project:e,committish:i,treepath:n,path:o,editpath:r})=>`https://${s}/${t}/${e}${d("/",n,"/",b(i||"HEAD"),"/",o,r)}`,tarballtemplate:({domain:s,user:t,project:e,committish:i})=>`https://${s}/${t}/${e}/get/${b(i||"HEAD")}.tar.gz`,extract:s=>{let[,t,e,i]=s.pathname.split("/",4);if(!["get"].includes(i)&&(e&&e.endsWith(".git")&&(e=e.slice(0,-4)),!(!t||!e)))return{user:t,project:e,committish:s.hash.slice(1)}}};x.gitlab={protocols:["git+ssh:","git+https:","ssh:","https:"],domain:"gitlab.com",treepath:"tree",blobpath:"tree",editpath:"-/edit",httpstemplate:({auth:s,domain:t,user:e,project:i,committish:n})=>`git+https://${d(s,"@")}${t}/${e}/${i}.git${d("#",n)}`,tarballtemplate:({domain:s,user:t,project:e,committish:i})=>`https://${s}/${t}/${e}/repository/archive.tar.gz?ref=${b(i||"HEAD")}`,extract:s=>{let t=s.pathname.slice(1);if(t.includes("/-/")||t.includes("/archive.tar.gz"))return;let e=t.split("/"),i=e.pop();i.endsWith(".git")&&(i=i.slice(0,-4));let n=e.join("/");if(!(!n||!i))return{user:n,project:i,committish:s.hash.slice(1)}}};x.gist={protocols:["git:","git+ssh:","git+https:","ssh:","https:"],domain:"gist.github.com",editpath:"edit",sshtemplate:({domain:s,project:t,committish:e})=>`git@${s}:${t}.git${d("#",e)}`,sshurltemplate:({domain:s,project:t,committish:e})=>`git+ssh://git@${s}/${t}.git${d("#",e)}`,edittemplate:({domain:s,user:t,project:e,committish:i,editpath:n})=>`https://${s}/${t}/${e}${d("/",b(i))}/${n}`,browsetemplate:({domain:s,project:t,committish:e})=>`https://${s}/${t}${d("/",b(e))}`,browsetreetemplate:({domain:s,project:t,committish:e,path:i,hashformat:n})=>`https://${s}/${t}${d("/",b(e))}${d("#",n(i))}`,browseblobtemplate:({domain:s,project:t,committish:e,path:i,hashformat:n})=>`https://${s}/${t}${d("/",b(e))}${d("#",n(i))}`,docstemplate:({domain:s,project:t,committish:e})=>`https://${s}/${t}${d("/",b(e))}`,httpstemplate:({domain:s,project:t,committish:e})=>`git+https://${s}/${t}.git${d("#",e)}`,filetemplate:({user:s,project:t,committish:e,path:i})=>`https://gist.githubusercontent.com/${s}/${t}/raw${d("/",b(e))}/${i}`,shortcuttemplate:({type:s,project:t,committish:e})=>`${s}:${t}${d("#",e)}`,pathtemplate:({project:s,committish:t})=>`${s}${d("#",t)}`,bugstemplate:({domain:s,project:t})=>`https://${s}/${t}`,gittemplate:({domain:s,project:t,committish:e})=>`git://${s}/${t}.git${d("#",e)}`,tarballtemplate:({project:s,committish:t})=>`https://codeload.github.com/gist/${s}/tar.gz/${b(t||"HEAD")}`,extract:s=>{let[,t,e,i]=s.pathname.split("/",4);if(i!=="raw"){if(!e){if(!t)return;e=t,t=null}return e.endsWith(".git")&&(e=e.slice(0,-4)),{user:t,project:e,committish:s.hash.slice(1)}}},hashformat:function(s){return s&&"file-"+bt(s)}};x.sourcehut={protocols:["git+ssh:","https:"],domain:"git.sr.ht",treepath:"tree",blobpath:"tree",filetemplate:({domain:s,user:t,project:e,committish:i,path:n})=>`https://${s}/${t}/${e}/blob/${b(i)||"HEAD"}/${n}`,httpstemplate:({domain:s,user:t,project:e,committish:i})=>`https://${s}/${t}/${e}.git${d("#",i)}`,tarballtemplate:({domain:s,user:t,project:e,committish:i})=>`https://${s}/${t}/${e}/archive/${b(i)||"HEAD"}.tar.gz`,bugstemplate:()=>null,extract:s=>{let[,t,e,i]=s.pathname.split("/",4);if(!["archive"].includes(i)&&(e&&e.endsWith(".git")&&(e=e.slice(0,-4)),!(!t||!e)))return{user:t,project:e,committish:s.hash.slice(1)}}};for(let[s,t]of Object.entries(x))x[s]=Object.assign({},Vt,t);yt.exports=x});var it=M((ve,Pt)=>{var Yt=A("url"),st=(s,t,e)=>{let i=s.indexOf(e);return s.lastIndexOf(t,i>-1?i:1/0)},St=s=>{try{return new Yt.URL(s)}catch{}},qt=(s,t)=>{let e=s.indexOf(":"),i=s.slice(0,e+1);if(Object.prototype.hasOwnProperty.call(t,i))return s;let n=s.indexOf("@");return n>-1?n>e?`git+ssh://${s}`:s:s.indexOf("//")===e+1?s:`${s.slice(0,e+1)}//${s.slice(e+1)}`},Jt=s=>{let t=st(s,"@","#"),e=st(s,":","#");return e>t&&(s=s.slice(0,e)+"/"+s.slice(e+1)),st(s,":","#")===-1&&s.indexOf("//")===-1&&(s=`git+ssh://${s}`),s};Pt.exports=(s,t)=>{let e=t?qt(s,t):s;return St(e)||St(Jt(e))}});var vt=M((Oe,At)=>{"use strict";var Kt=it(),Xt=s=>{let t=s.indexOf("#"),e=s.indexOf("/"),i=s.indexOf("/",e+1),n=s.indexOf(":"),o=/\s/.exec(s),r=s.indexOf("@"),a=!o||t>-1&&o.index>t,h=r===-1||t>-1&&r>t,f=n===-1||t>-1&&n>t,w=i===-1||t>-1&&i>t,u=e>0,m=t>-1?s[t-1]!=="/":!s.endsWith("/"),p=!s.startsWith(".");return a&&u&&m&&p&&h&&f&&w};At.exports=(s,t,{gitHosts:e,protocols:i})=>{if(!s)return;let n=Xt(s)?`github:${s}`:s,o=Kt(n,i);if(!o)return;let r=e.byShortcut[o.protocol],a=e.byDomain[o.hostname.startsWith("www.")?o.hostname.slice(4):o.hostname],h=r||a;if(!h)return;let f=e[r||a],w=null;i[o.protocol]?.auth&&(o.username||o.password)&&(w=`${o.username}${o.password?":"+o.password:""}`);let u=null,m=null,p=null,P=null;try{if(r){let l=o.pathname.startsWith("/")?o.pathname.slice(1):o.pathname,y=l.indexOf("@");y>-1&&(l=l.slice(y+1));let c=l.lastIndexOf("/");c>-1?(m=decodeURIComponent(l.slice(0,c)),m||(m=null),p=decodeURIComponent(l.slice(c+1))):p=decodeURIComponent(l),p.endsWith(".git")&&(p=p.slice(0,-4)),o.hash&&(u=decodeURIComponent(o.hash.slice(1))),P="shortcut"}else{if(!f.protocols.includes(o.protocol))return;let l=f.extract(o);if(!l)return;m=l.user&&decodeURIComponent(l.user),p=decodeURIComponent(l.project),u=decodeURIComponent(l.committish),P=i[o.protocol]?.name||o.protocol.slice(0,-1)}}catch(l){if(l instanceof URIError)return;throw l}return[h,m,w,p,u,P,t]}});var Tt=M((Te,Ot)=>{"use strict";var{LRUCache:Qt}=wt(),Zt=$t(),te=vt(),ee=it(),nt=new Qt({max:1e3}),V=class s{constructor(t,e,i,n,o,r,a={}){Object.assign(this,s.#n[t],{type:t,user:e,auth:i,project:n,committish:o,default:r,opts:a})}static#n={byShortcut:{},byDomain:{}};static#l={"git+ssh:":{name:"sshurl"},"ssh:":{name:"sshurl"},"git+https:":{name:"https",auth:!0},"git:":{auth:!0},"http:":{auth:!0},"https:":{auth:!0},"git+http:":{auth:!0}};static addHost(t,e){s.#n[t]=e,s.#n.byDomain[e.domain]=t,s.#n.byShortcut[`${t}:`]=t,s.#l[`${t}:`]={name:t}}static fromUrl(t,e){if(typeof t!="string")return;let i=t+JSON.stringify(e||{});if(!nt.has(i)){let n=te(t,e,{gitHosts:s.#n,protocols:s.#l});nt.set(i,n?new s(...n):void 0)}return nt.get(i)}static parseUrl(t){return ee(t)}#e(t,e){if(typeof t!="function")return null;let i={...this,...this.opts,...e};i.path||(i.path=""),i.path.startsWith("/")&&(i.path=i.path.slice(1)),i.noCommittish&&(i.committish=null);let n=t(i);return i.noGitPlus&&n.startsWith("git+")?n.slice(4):n}hash(){return this.committish?`#${this.committish}`:""}ssh(t){return this.#e(this.sshtemplate,t)}sshurl(t){return this.#e(this.sshurltemplate,t)}browse(t,...e){return typeof t!="string"?this.#e(this.browsetemplate,t):typeof e[0]!="string"?this.#e(this.browsetreetemplate,{...e[0],path:t}):this.#e(this.browsetreetemplate,{...e[1],fragment:e[0],path:t})}browseFile(t,...e){return typeof e[0]!="string"?this.#e(this.browseblobtemplate,{...e[0],path:t}):this.#e(this.browseblobtemplate,{...e[1],fragment:e[0],path:t})}docs(t){return this.#e(this.docstemplate,t)}bugs(t){return this.#e(this.bugstemplate,t)}https(t){return this.#e(this.httpstemplate,t)}git(t){return this.#e(this.gittemplate,t)}shortcut(t){return this.#e(this.shortcuttemplate,t)}path(t){return this.#e(this.pathtemplate,t)}tarball(t){return this.#e(this.tarballtemplate,{...t,noCommittish:!1})}file(t,e){return this.#e(this.filetemplate,{...e,path:t})}edit(t,e){return this.#e(this.edittemplate,{...e,path:t})}getDefaultRepresentation(){return this.default}toString(t){return this.default&&typeof this[this.default]=="function"?this[this.default](t):this.sshurl(t)}};for(let[s,t]of Object.entries(Zt))V.addHost(s,t);Ot.exports=V});var we={};H(we,{default:()=>ge});var Rt=A("@yarnpkg/cli"),z=A("@yarnpkg/core"),_=A("clipanion");var g=A("@yarnpkg/core"),F=A("@yarnpkg/fslib"),Ct=Ht(Tt());var ot={};H(ot,{_getYarnStateAliases:()=>Et,getFs:()=>ne,getPackagePath:()=>se});var C=A("@yarnpkg/core"),k=A("@yarnpkg/fslib"),Ft=A("@yarnpkg/parsers");var I=()=>({os:[process.platform],cpu:[process.arch],libc:[]});var se=async(s,t)=>{if(await ie(s),!C.structUtils.isPackageCompatible(t,I()))return null;let e=C.structUtils.convertPackageToLocator(t),i=C.structUtils.stringifyLocator(e),n=Y[i]||_t[i];if(!n)return null;let o=n.locations[0];return o?k.ppath.join(s.cwd,o):s.cwd},Y,_t,ie=async s=>{if(!Y){let t=k.ppath.join(s.configuration.projectCwd,k.Filename.nodeModules,".yarn-state.yml");Y=(0,Ft.parseSyml)(await k.xfs.readFilePromise(t,"utf8")),_t=Et(Y)}},ne=()=>k.xfs,Et=s=>Object.entries(s).reduce((t,[e,i])=>{if(!i.aliases)return t;let n=C.structUtils.parseLocator(e);for(let o of i.aliases){let r=C.structUtils.makeLocator(n,o),a=C.structUtils.stringifyLocator(r);t[a]=i}return t},{});var ht={};H(ht,{getFs:()=>ae,getPackagePath:()=>oe});var q=A("@yarnpkg/core"),xt=A("@yarnpkg/fslib"),J=A("@yarnpkg/libzip"),kt=A("@yarnpkg/plugin-pnp");var oe=async(s,t)=>{if(re(s),!q.structUtils.isPackageCompatible(t,I()))return null;let e=q.structUtils.convertPackageToLocator(t),i={name:q.structUtils.stringifyIdent(e),reference:e.reference.startsWith("virtual:")?e.reference.split("#")[1]:e.reference},n=rt.getPackageInformation(i);if(!n)return null;let{packageLocation:o}=n;return o},rt,re=s=>{rt||(rt=module.require((0,kt.getPnpPath)(s).cjs))},ae=()=>(he(),at),at,he=()=>{at||(at=new xt.VirtualFS({baseFs:new J.ZipOpenFS({libzip:(0,J.getLibzipSync)(),readOnlyArchives:!0})}))};var lt={};H(lt,{getFs:()=>ce,getPackagePath:()=>le});var N=A("@yarnpkg/core"),W=A("@yarnpkg/fslib");var le=async(s,t)=>{if(!N.structUtils.isPackageCompatible(t,I()))return null;let e=N.structUtils.convertPackageToLocator(t),i=N.structUtils.slugifyLocator(e),n=N.structUtils.stringifyIdent(e),o=s.tryWorkspaceByLocator(e);return o?o.cwd:W.ppath.join(s.configuration.projectCwd,W.Filename.nodeModules,".store",i,W.Filename.nodeModules,n)},ce=()=>W.xfs;var Lt=s=>{switch(s){case"pnp":return ht;case"node-modules":return ot;case"pnpm":return lt;default:throw new Error("Unsupported linker")}};var Je=F.npath.basename(__dirname)==="@yarnpkg"?F.ppath.join(F.npath.toPortablePath(__dirname),"../.."):F.ppath.join(F.npath.toPortablePath(__dirname),".."),Wt=async(s,t,e,i,n)=>{let o={},r={children:o},a=await fe(s,e,i),h=Lt(s.configuration.get("nodeLinker")),f=h.getFs();for(let[w,u]of a.entries()){let m=await h.getPackagePath(s,u);if(m===null)continue;let p=JSON.parse(await f.readFilePromise(F.ppath.join(m,F.Filename.manifest),"utf8")),{license:P,url:l,vendorName:y,vendorUrl:c}=de(p);o[P]||(o[P]={value:g.formatUtils.tuple(g.formatUtils.Type.NO_HINT,P),children:{}});let S=g.structUtils.convertPackageToLocator(u),O=g.formatUtils.tuple(g.formatUtils.Type.DEPENDENT,{locator:S,descriptor:w}),$=n?{}:{...l?{url:{value:g.formatUtils.tuple(g.formatUtils.Type.NO_HINT,ct("URL",l,t))}}:{},...y?{vendorName:{value:g.formatUtils.tuple(g.formatUtils.Type.NO_HINT,ct("VendorName",y,t))}}:{},...c?{vendorUrl:{value:g.formatUtils.tuple(g.formatUtils.Type.NO_HINT,ct("VendorUrl",c,t))}}:{}},v={value:O,children:$},L=g.structUtils.stringifyLocator(S),T=o[P];if(T){let U=T.children;U[L]=v}}return r},fe=async(s,t,e)=>{let i=new Map,n;if(t){if(e){for(let h of s.workspaces)h.manifest.devDependencies.clear();let a=await g.Cache.find(s.configuration);await s.resolveEverything({report:new g.ThrowReport,cache:a})}n=s.storedDescriptors.values()}else n=s.workspaces.flatMap(a=>{let h=[a.anchoredDescriptor];for(let[f,w]of a.anchoredPackage.dependencies.entries())e&&a.manifest.devDependencies.has(f)||h.push(w);return h});let o=g.miscUtils.sortMap(n,[a=>g.structUtils.stringifyIdent(a),a=>g.structUtils.isVirtualDescriptor(a)?"0":"1",a=>a.range]),r=new Set;for(let a of o.values()){let h=s.storedResolutions.get(a.descriptorHash);if(!h)continue;let f=s.storedPackages.get(h);if(!f)continue;let{descriptorHash:w}=g.structUtils.isVirtualDescriptor(a)?g.structUtils.devirtualizeDescriptor(a):a;r.has(w)||(r.add(w),i.set(a,f))}return i},Ut=async(s,t,e,i)=>{if(!t.length)return;let n=new Set(t.map(r=>s.getWorkspaceByIdent(g.structUtils.parseIdent(r))));if(e)for(let r of n)for(let a of i?["dependencies"]:g.Manifest.hardDependencies)for(let h of r.manifest.getForScope(a).values()){let f=s.tryWorkspaceByDescriptor(h);f!==null&&n.add(f)}for(let r of s.workspaces)n.has(r)||(r.manifest.installConfig=r.manifest.installConfig||{},r.manifest.installConfig.selfReferences=!1,r.manifest.dependencies.clear(),r.manifest.devDependencies.clear(),r.manifest.peerDependencies.clear());s.workspaces=[...n];let o=await g.Cache.find(s.configuration);await s.resolveEverything({report:new g.ThrowReport,cache:o})};function ue(s){let t={},e=s.match(/^([^(<]+)/);if(e){let o=e[0].trim();o&&(t.name=o)}let i=s.match(/<([^>]+)>/);i&&(t.email=i[1]);let n=s.match(/\(([^)]+)\)/);return n&&(t.url=n[1]),t}var de=s=>{let{license:t,licenses:e,repository:i,homepage:n,author:o}=s,r=typeof o=="string"?ue(o):o;return{license:(()=>{if(t)return K(t);if(e){if(!Array.isArray(e))return K(e);if(e.length===1&&e[0])return K(e[0]);if(e.length>1)return`(${e.map(K).join(" OR ")})`}return Dt})(),url:pe(i)||n,vendorName:r?.name,vendorUrl:n||r?.url}},Dt="UNKNOWN",K=s=>(typeof s!="string"?s.type:s)||Dt,pe=s=>{let t=typeof s=="string"?s:s?.url;if(!t)return t;let e=Ct.fromUrl(t);return!e||e.getDefaultRepresentation()!=="shortcut"?t:e.https()},ct=(s,t,e)=>e?t:`${s}: ${t}`;var X=class extends _.Command{static paths=[["licenses","list"]];static usage=_.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.

      If \`--focus\` is passed, the listing will only include dependencies of the specified workspaces.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"],["List all licenses for specified workspaces only","$0 licenses list --focus <workspace-a> --focus <workspace-b>"]]});recursive=_.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});production=_.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});json=_.Option.Boolean("--json",!1,{description:"Format output as JSON"});excludeMetadata=_.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"});focus=_.Option.Array("--focus",[],{description:"Focus on one or more workspaces"});async execute(){let t=await z.Configuration.find(this.context.cwd,this.context.plugins),{project:e,workspace:i}=await z.Project.find(t,this.context.cwd);if(!i)throw new Rt.WorkspaceRequiredError(e.cwd,this.context.cwd);await e.restoreInstallState(),await Ut(e,this.focus,this.recursive,this.production);let n=await Wt(e,this.json,this.recursive,this.production,this.excludeMetadata);z.treeUtils.emitTree(n,{configuration:t,stdout:this.context.stdout,json:this.json,separators:1})}};var me={commands:[X]},ge=me;return Gt(we);})();
return plugin;
}
};
